frame-stacker-container {
	display: block;

	/*
		Note - position fixed is well supported, but still doesn't work on opera mini. If you want to support that, then you'll have to set position to absolute, and either:
			use a scroll listener to maintain the correct "top" value

			use something like tether.js to tether the layer to viewport

			nest an inner scrolling container inside of the body element, and set html, body {height: 100%;}  

			TODO - should we provide support for opera-mini directly?
			If "position: fixed" not supported, then use absolute, and add our own scroll listener

		https://caniuse.com/#feat=css-fixed
	*/
	position: fixed;
	top: 0;
	left: 0;
	height: 100%;
	width: 100%;
}

/*
	When there are any iframe layers open, frame-stacker-container should capture all mouse clicks that don't land on an iframe.

	When there are no iframes open, clicks should pass through.
	IMPORTANT - there can be no whitespace inside the element, or it will never match :empty

	It would be nice to remove the container entirely when it's empty, but currently we don't actually know when this happens. When we call remove() on the last layer, it is allowed to animate the frame out (and we don't ask it to tell us when it's done).
*/
frame-stacker-container:empty {
	pointer-events: none;
}

/*
	plugins may decide to wrap iframe in other elements, and those may extend beyond the iframe. If so, clicks on those wrapper elements should fall through - they should not be interactive in any way.
	
	When any iframe layers are open, all clicks should either land on one of the iframes or on the frame-stacker-container. This way we can be sure to handle all click events, and know which layer the user intended to click on.
*/
frame-stacker-container > * {
	pointer-events: none;
}
frame-stacker-container iframe {
	pointer-events: auto;
}